<!DOCTYPE html>
<html lang="en">
  <head>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather&
    display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:700&display
    =swap" rel="stylesheet"/>
    <link rel="stylesheet" href="styles/main.css" />
    <script type="module" src="scripts/skills.mjs" defer></script>
    <title>George: Skills</title>
  </head>

  <header id='header'></header>

<section id="welcome-section">
  <div id= "top-logos" class="logos"></div>
  <div id="welcome-box">
    <h1>Do you need a website or some data analysing?</h1>
    <h3 id="subtitle"><i>I've got you covered...</i></h3>
  </div>
  <div id= "bottom-logos" class="logos"></div>
</section>

<section id="projects">
  <h2><u>Here are some of my projects:</u></h2>
  <div class="flex-grid">
    <div class="skillsCard project-tile">
      <div>
      <h3>Data Analysis</h3>
      <hr>
        <p><a class="jump-link" href="#code1">This code</a> reads a .csv file
          containing data about customer purchases across a 3 year period
          including average rating and average product value. The aim is to
          select 100 favourable customers (using all purchase info) who will
          be sent a voucher. </p>
      </div>
    </div>
   <div class="skillsCard project-tile">
      <div>
      <h3>Creating a Trading Strategy</h3>
      <hr>
      <p><a class="jump-link" href="#code2">This code</a> is part of a virtual
        stock market in Python where the user can load stock data and
        portfolios. This automatic trading strategy has been extensively tested
        and will always lead to an (albeit small) profit by measuring the
        stability of each stock and tracking price-gain ratios.</p>
      </div>
    </div>
   <div class="skillsCard project-tile">
      <div>
      <h3>Basic Games Design</h3>
      <hr>
      <p>When I returned from travelling Australia I followed an online Java
        course where I built a basic sandbox game using JavaFX. I learnt alot
        about how medium level programming languages work and became familiar
        with OOP. See some of the source code
        <a class="jump-link" href="#code3">here</a>.</p>
      </div>
    </div>
    <div class="skillsCard project-tile">
      <div>
      <h3>Web Development</h3>
      <hr>
      <p>Since finishing university I have been learning web development. After
        learning the fundamentals of HTML/CSS, I am currently taking Udemy
        courses covering JavaScript including server-side development using
        Node.js so I can build websites from scratch for myself and family/
        friends. <br><br> Access a tribute page I made <a href="https://codepen.
        io/gm4321/full/OJMXaNR" class="jump-link" target="_blank">here</a>.</p>
      </div>
    </div>
  </div>
</section>

<section id="skills">
  <h2><u>Here are some key skills I have:</u></h2>
  <div class="flex-grid">
    <div class="skillsCard skill-tile">
      <div>
      <h3>Problem Solving</h3>
      <hr>
      <p>Have experience solving problems in range of fields including using JS
        event handlers, Mathematical logic, working with large datasets and
        managing large OOP projects.</p>
      </div>
    </div>
   <div class="skillsCard skill-tile">
      <div>
      <h3>Creativity</h3>
      <hr>
      <p>Third year level Maths courses require the ability to think out of the
        box and approach problems creatively. After learning Intermediate French
        and travelling Australia I learnt about different cultures and to view
        the world from a different perspective.</p>
      </div>
    </div>
   <div class="skillsCard skill-tile">
      <div>
      <h3>Attention to Detail</h3>
      <hr>
      <p>A key part of working with large datasets in machine learning courses
        is to be aware of all seemingly miniscule data properties. Varied
        experience debugging code in Python, Matlab, Java and CSS/HTML showed
        me the importance of planning well-structured code to avoid a
        debugging nightmare.</p>
      </div>
    </div>
    <div class="skillsCard skill-tile">
      <div>
      <h3>Dedication</h3>
      <hr>
      <p>After working hard to achieve an upper 2:1 and also working on coding
        projects outside of the classroom, I have the dedication needed to
        advance my coding skills. Whether working part-time or travelling, I am
        an individual who strives to improve in everything I do.</p>
      </div>
    </div>
    <div class="skillsCard skill-tile">
      <div>
      <h3>Teamwork</h3>
      <hr>
      <p>I have a variety of work experiences including; working as a Team
        Leader at NCS working with young people, getting to know the Manchester
        public after working in Customer Service and completing a Spring
        Internship at Deloitte. From this varied life experience the main lesson
        I learnt is that unlocking the potential of all your colleagues is the
        best path to success.</p>
      </div>
    </div>
  </div>
</section>

<section id="code-section">
  <h2>Here's some more code I have written:</h2>
  <h3 id="code1"><u>Data Analysis using Pandas</u></h3>
  <div class="code-box">
    <a href="https://code.sololearn.com/cKFZPzTLbb3o" class="info-link"
    target="_blank">coupons.py (click to open in new tab)</a><br>
    <code><pre>import numpy as np
import pandas as pd

"""
An auxillary function which returns true if k is in the list d, otherwise false
"""
def ismember(k, d):
    temp = [1 if (i == k) else 0 for i in d]
    if sum(temp) > 0:
        return True
    else:
        return False

"""
Returns a table including 100 customers who have the highest average of
clothes purchase product value and review score. CustomerIDs are ranked
by their score. Created a matrix of data about customers for calculations
"""
def coupons(filename):
    df = pd.read_csv(filename, index_col='Customer_ID', parse_dates=['Date'])

    # Add all customer IDs to a list
    customers = list()
    for i in df.index.values:
        if not ismember(i,customers):
            customers.append(i)

    """
    Complete lists with the total value and number of electric items/reviews for
    each customer Electrics will be product category 'D'
    """
    numberElectrics = list()
    totalElectrics = list()
    numberReviews = list()
    totalReviews = list()
    for p in customers:
        numberElectric = 0
        totalElectric = 0
        numberReview = 0
        totalReview = 0
        currentDF = df.loc[p]
        for i in range(len(currentDF)):
            if currentDF.iloc[i,1] == 'D':
                numberElectric += 1
                totalElectric += currentDF.iloc[i,2]
            numberReview += 1
            totalReview += currentDF.iloc[i,3]
        numberElectrics.append(numberElectric)
        totalElectrics.append(totalElectric)
        numberReviews.append(numberReview)
        totalReviews.append(totalReview)

    """
    Find a list for the average value of each electrics purchase and average
    review score for each customer
    """
    avgElectrics = list()
    avgReviews = list()
    for i in range(len(numberReviews)):
        if totalElectrics[i] != 0:
            avgElectrics.append(totalElectrics[i]/numberElectrics[i])
        else:
            avgElectrics.append(0)
        if totalReviews[i] != 0:
            avgReviews.append(totalReviews[i]/numberReviews[i])
        else:
            avgReviews.append(0)

    """
    Put all the above lists into a table
    """
    colnames = ['Customer ID', '# of Electrics Bought',
    'Total Value of Electrics','Avg Electrics Value', '# of Reviews',
    'Total Reviews Score', 'Avg Review Score']
    data = pd.DataFrame(list(zip(customers, numberElectrics,
            totalElectrics, avgElectrics, numberReviews,
            totalReviews, avgReviews)), columns=colnames)

    data2 = data.transpose()
    data2.to_csv('data.csv')

    """
    Create a list of weighted score to find customers with the best average
    electrics spend and also average rating score. 11.5538 will properly scale
    the ratings so they are measured as equal to electrics purchases
    """
    weightedScore = list()
    for i in range(len(avgElectrics)):
        weightedScore.append(avgElectrics[i] + 11.5538*avgReviews[i])

    """
    Now return a list of the top100 customer IDs together with their score
    """
    top100Scores = list()
    top100Indexes = list()
    top100 = list()
    c = 0
    while c < 100:
        for i in range(len(weightedScore)):
            if weightedScore[i] == max(weightedScore):
                top100Scores.append(weightedScore[i])
                top100Indexes.append(i)
                weightedScore[i] = -1
                break
        top100.append(customers[i])
        c += 1

    return list(zip(top100, top100Scores))

print(coupons('purchasing_order.csv')) </pre></code>
  </div>
  <h3 id="code2"><u>Trading Strategy using stockprice data</u></h3>
  <div class="code-box">
    <a href="https://code.sololearn.com/cAd8nR0Wdr9u" class="info-link"
    target="_blank">tradeStrategy.py (click to open in new tab)</a><br>
    <code><pre>from os import listdir
def tradeStrategy2(verbose=False):
    """
    This strategy works using 2 principles;
    1) Shares with a relatively constant share price, which are not prone to
    sudden price changes, seem to be a safer investment
    2) If a share price has gained massively, then it is prone to a later lapse
    in price. Hence it is a good time to sell after a big price hike

    The 5 least volatile stocks are bought on the 225th trading day, or the date
    of the portfolio. These stocks are only sold if there is a significant
    increase in their price (x1.7). The aim is to only buy less risky stocks
    and keep transactions to a minimum to avoid losses.

    Data from the stocks dictionary is used hence stocks must be loaded, and
    the portfolio dictionary is modified accordingly.

    This is a conservative strategy compared to tradeStrategy1, hopefully
    fitted for investors who aim to guarantee a small profit but not aim big
    """
    m=225 #the number of trading days to consider stock data
    n=5 #the number of stocks to buy
    r=1.7 #the price gain ratio at which to sell any stocks
    lstdates = list()
    for i in stocks:
        for j in stocks[i]:
            lstdates.append(normaliseDate(j))
        break
    lstdates.sort()
    def H(s,j):
        return stocks[s][lstdates[j]][1]
    def L(s,k):
        return stocks[s][lstdates[k]][2]
    def MaxH(s,j): #max high price of s over 200 days previously from day j
        highs = list()
        for i in range(m):
            highs.append(stocks[s][lstdates[j-i]][1])
        return max(highs)
    def MinL(s,j): #min low price of stock s over 200 days previously from day j
        lows = list()
        for i in range(m):
            lows.append(stocks[s][lstdates[j-i]][2])
        return min(lows)
    def Q_buy2(s,j): #variation in price in 200 days prior to i
        return MaxH(s,j) / MinL(s,j)
    def Q_sell(s,j,k): #a measure of how much value the stock has added/removed
        return L(s,k) / H(s,j)
    try:
        k = lstdates.index(normaliseDate(portfolio['date'])) #numbered day
    except ValueError: #if portfolio is not trading day, just choose day m-1
        k = m-1
    if k < m-1:
        k = m-1
    qbuys = list()
    for s in stocks:
        qbuys.append(abs(Q_buy2(s,k) -1))
    qbuys.sort()
    topn = qbuys[:n] #So we aim to buy the top n stocks
    msps = (portfolio['cash'])/n #maximum spend per stock
    for s in stocks:
        if abs(Q_buy2(s,k) -1) in topn:
            v = 0
            while (stocks[s][lstdates[k]][1])*v <= msps:
                v +=1
            else:
                v -= 1 #so the volume is the maximum whilst still having cash
           addTransaction({'date':lstdates[k], 'symbol':s, 'volume':v}, verbose)
    #so we have bought n least volatile stocks. Now sell stocks if price gain
    for x in ld("stockdata/"):
        if x[:-4] in portfolio:
            l = k
            while Q_sell(x[:-4],k,l) < r and l < len(lstdates)-1:
                l +=1
            if l < len(lstdates)-1:
                try:
                    addTransaction(
                    {'date':lstdates[l], 'symbol':x[:-4],
                    'volume':-1*portfolio[x[:-4]]}, verbose)
                except DateError: #if attempt to perform transaction before
                portfolio date, unavoidable as stocks looked at 1 by 1
                    pass #simply do not carry out transaction </pre></code>
  </div>
  <h3 id="code3"><u>Part of a basic Minecraft-type game</u></h3>
  <div class="code-box">
    <a href="https://code.sololearn.com/cuBp72zNw4jH" class="info-link"
    target="_blank">WorldMap.java (click to open in new tab)</a><br>
    <code><pre>package csse2002.block.world;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class WorldMap extends Object {

    /**A sparse tile array which stores all the tiles on this world map
     */
    private SparseTileArray worldMapTiles;

    /**A builder, who is the current builder
     */
    private Builder worldMapBuilder;

    /**Creates a World Map with the Builder specified as an argument and the
     * builder's start tile and position given. All tiles and positions are
     * created using the 'addLinkedTiles' method from Sparse Tile Array
     * @param startingTile is the start tile of the builder
     * @param startPosition is the start position of the builder
     * @param builder is the builder of our world map
     * @throws WorldMapInconsistentException if the 'addLinkedTiles' method
     * resulted in geometrically inconsistent tiles
     */
    public WorldMap(csse2002.block.world.Tile startingTile,
                    Position startPosition,
                    csse2002.block.world.Builder builder)
            throws WorldMapInconsistentException {
        worldMapBuilder = builder;
        worldMapTiles = new SparseTileArray();
        worldMapTiles.addLinkedTiles(startingTile, startPosition.getX(),
                startPosition.getY());
    }

    /** A private method which is used in the WorldMap constructor below
     * multiple times. This adds a string of blocks separated by commas to
     * a list
     * @param string is a string of comma separated blocks from a file input
     * @param blocks will be a list of blocks to append
     * @throws InvalidBlockException if any blocks have an invalid name
     */
    private void addBlocksString(String string, List<Block> blocks)
            throws InvalidBlockException {
        try {
            String[] items = string.split(",");
            for (String i : items) {
                if (i.equals("stone")) {
                    blocks.add(new StoneBlock());
                } else if (i.equals("wood")) {
                    blocks.add(new WoodBlock());
                } else if (i.equals("grass")) {
                    blocks.add(new GrassBlock());
                } else if (i.equals("soil")) {
                    blocks.add(new SoilBlock());
                } else {
                    throw new InvalidBlockException(); }
            }
        } catch (Exception e) {
            throw new InvalidBlockException();
        }
    }

    /** Creates a World Map from a filename given as an argument. The filename
     * must be in a certain format. This constructor checks that the filename is
     * in the required format. This filename creates a builder in a given start
     * position with an inventory. The tiles and their positions on the Sparse
     * Array are inputted. worldMapBuilder and worldMapTiles are appended
     * accordingly.
     * @param filename is the file which to find world map data from
     * @throws WorldMapFormatException if the world map input is formatted
     * incorrectly
     * @throws WorldMapInconsistentException if the world map has
     * geometrically inconsistent tiles
     * @throws FileNotFoundException if the filename input does not read
     */
    public WorldMap(String filename) throws WorldMapFormatException,
            WorldMapInconsistentException, java.io.FileNotFoundException {
        List<String> lines = new ArrayList<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(filename));
            String line = null;
            while ( (line = br.readLine()) != null) {
                lines.add(line);
            }
            br.close();
        } catch (java.io.IOException e) {
            if (e instanceof FileNotFoundException) {
                throw new FileNotFoundException();
            } else { throw new WorldMapFormatException(); }
        }
        try {
            Position startPosition = new Position(Integer.valueOf(lines.get(0)),
                    Integer.valueOf(lines.get(1)));

            //Create the starting Tile
            String startBlocks = lines.get(6).substring(2);
            List<Block> startTileBlocks = new ArrayList<>();
            addBlocksString(startBlocks, startTileBlocks);
            Tile startingTile = new Tile(startTileBlocks);

            //Create the builder
            String inventoryItems = lines.get(3);
            List<Block> builderInventory = new ArrayList<>();
            addBlocksString(inventoryItems, builderInventory);
            Builder builder = new Builder(lines.get(2),
                    startingTile, builderInventory);
            worldMapBuilder = builder;

            List<Tile> tiles = new ArrayList<>();
            tiles.add(startingTile);

            if (!(lines.get(4).equals(""))) {
                throw new WorldMapFormatException();
            }

            //Create the other tiles
            int numberTiles = Integer.valueOf(lines.get(5).substring(6));
            for (int i=7; i < 6+numberTiles; i++) {
                String blocks = lines.get(i).substring(2);
                int z = Character.getNumericValue(lines.get(i).charAt(0));
                if (z < 0 || z > numberTiles -1) {
                    throw new WorldMapFormatException();
                }
                List<Block> tileBlocks = new ArrayList<>();
                addBlocksString(blocks, tileBlocks);
                tiles.add(new Tile(tileBlocks));
                if (lines.get(i).equals("")) {
                    throw new WorldMapFormatException();
                }
            }

            if (!(lines.get(6+numberTiles).equals(""))) {
                throw new WorldMapFormatException();
            }
            //Create the exits
            for (int i=0; i < numberTiles; i++) {
                String[] exits =
                        lines.get(8 + numberTiles + i).
                                substring(2).split(",");
                //Splitting each "east:2" into the direction and target index
                for (String k : exits) {
                    int targetIndex = Integer.valueOf(k.substring(k.length()-1,
                            k.length()));
                    String exitName = k.substring(0,k.length()-2);
                    if (!(exitName.equals("north")) &&
                            !(exitName.equals("east")) &&
                            !(exitName.equals("south")) &&
                            !(exitName.equals("west"))) {
                        throw new NoExitException();
                    }
                    tiles.get(i).addExit(exitName, tiles.get(targetIndex));
                }
                //An IndexOOBoundsException means that there are not N exits,
                // hence a WorldMapFormatException is thrown
            }

            //Finally, create the SparseTileArray
            worldMapTiles = new SparseTileArray();
            worldMapTiles.addLinkedTiles(startingTile, startPosition.getX(),
                    startPosition.getX());

        } catch (InvalidBlockException e1){
            throw new WorldMapFormatException();
        } catch (TooHighException e2){
            throw new WorldMapFormatException();
        } catch (NoExitException e3){
            throw new WorldMapFormatException();
        } catch (NumberFormatException e4){
            throw new WorldMapFormatException();
        } catch (IndexOutOfBoundsException e5) {
            throw new WorldMapFormatException();
        }
    }

    /** @return the worldMapBuilder parameter of the current Map
     */
    public csse2002.block.world.Builder getBuilder() { return worldMapBuilder; }

    /**This function finds the position of the starting Tile for this World Map
     * @return a key value from the 'tiles' map of the Sparse Tile Array
     * or null if this tile is not in the map
     */
    public Position getStartPosition() {
        //TODO: Try and do this without needing access to worldMapTiles.tiles
        for (Position p : worldMapTiles.tiles.keySet()) {
            if (worldMapTiles.getTile(p) == worldMapTiles.getTiles().get(0)) {
                return p;
            }
        }
        return null;
    }

    /**Gets the tile from 'worldMapTiles' which corresponds to a position
     * @param position is a key in the tiles variable corresponding to the
     * desired tile
     * @return the desired tile
     */
    public csse2002.block.world.Tile getTile(Position position) {
        return worldMapTiles.getTile(position);
    }

    /** @return all the tiles listed in the 'worldMapTiles' sparse tile array
     */
    public java.util.List<csse2002.block.world.Tile> getTiles() {
        return worldMapTiles.getTiles();
    }

    /**Saves the given WorldMap to a file specified by the filename. This file
     * will be in a format readable by the WorldMap constructor.
     * Inputs information onto 'filename' using a StringBuilder and Buffered
     * Writer. Builder information comes from 'worldMapBuilder' and tile/exit
     * information comes from the getStartPosition() and getTiles() methods
     * @param filename is where to save the world map
     * @throws IOException if there is a problem saving the file
     */
    public void saveMap(java.lang.String filename) throws java.io.IOException {
        List<String> strings = new ArrayList<>();
        strings.add(Integer.toString(getStartPosition().getX()));
        strings.add(Integer.toString(getStartPosition().getY()));
        strings.add(worldMapBuilder.getName());

        StringBuilder stringBuilder = new StringBuilder();
        for (Block b : worldMapBuilder.getInventory()) {
            stringBuilder.append(b.getBlockType());
            stringBuilder.append(",");
        }
        stringBuilder.deleteCharAt(stringBuilder.length()-1);
        strings.add(stringBuilder.toString());
        stringBuilder.setLength(0);
        strings.add("");

        //Now add the tiles and their blocks
        strings.add("total:" + Integer.toString(getTiles().size()));
        for (Tile t : getTiles()) {
            stringBuilder.append(getTiles().indexOf(t) + " ");
            for (Block b : t.getBlocks()) {
                stringBuilder.append(b.getBlockType());
                stringBuilder.append(",");
            }
            stringBuilder.deleteCharAt(stringBuilder.length()-1);
            strings.add(stringBuilder.toString());
            stringBuilder.setLength(0);
        }
        strings.add("");

        //Now add tile exits with the blocks they lead to
        strings.add("exits");
        for (Tile t : getTiles()) {
            stringBuilder.append(getTiles().indexOf(t) + " ");
            for (Map.Entry<String, Tile> entry : t.getExits().entrySet() ) {
                stringBuilder.append(entry.getKey() + ":" +
                        Integer.toString(getTiles().indexOf(entry.getValue())));
                stringBuilder.append(",");
            }
            stringBuilder.deleteCharAt(stringBuilder.length()-1);
            strings.add(stringBuilder.toString());
            stringBuilder.setLength(0);
        }

        //Now write all this using a BufferedWriter
        BufferedWriter writer = null;
        writer = new BufferedWriter(new FileWriter(filename));
        for (String s : strings) {
            writer.write(s);
            writer.newLine();
        }
        writer.close();
    }
} </pre></code>
  </div>
</section>
</html>
